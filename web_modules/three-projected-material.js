import{ShaderMaterial as e,ShaderLib as t,Color as a,Matrix4 as r,ShaderChunk as o,InstancedBufferAttribute as n}from"./three.js";function i(e,{header:t="",main:a="",...r}){let o=e;return Object.keys(r).forEach(e=>{o=o.replace(e,r[e])}),o.replace("void main() {",`\n    ${t}\n    void main() {\n      ${a}\n    `)}function l(e,t,a,r){const o=e.image.naturalWidth/e.image.naturalHeight,n=t.aspect,i=1/n*1;let l,s;if(r?o>n:o<n){l=1/(i*o/1*a),s=1/a}else{s=1/(1/o*1/i*a),l=1/a}return[l,s]}function s(e){if(!e.material.isProjectedMaterial)throw new Error("The mesh material must be a ProjectedMaterial");e.updateMatrixWorld(),e.material.uniforms.savedModelMatrix.value.copy(e.matrixWorld)}function d(e,t,a){if(!t.isInstancedMesh)throw new Error("The provided mesh is not an InstancedMesh");if(!t.material.isProjectedMaterial)throw new Error("The InstancedMesh material must be a ProjectedMaterial");if(!(t.geometry.attributes.savedModelMatrix0&&t.geometry.attributes.savedModelMatrix1&&t.geometry.attributes.savedModelMatrix2&&t.geometry.attributes.savedModelMatrix3))throw new Error("No allocated data found on the geometry, please call 'allocateProjectionData(geometry)'");if(!t.material.instanced)throw new Error("Please pass 'instanced: true' to the ProjectedMaterial");t.geometry.attributes.savedModelMatrix0.setXYZW(e,a.elements[0],a.elements[1],a.elements[2],a.elements[3]),t.geometry.attributes.savedModelMatrix1.setXYZW(e,a.elements[4],a.elements[5],a.elements[6],a.elements[7]),t.geometry.attributes.savedModelMatrix2.setXYZW(e,a.elements[8],a.elements[9],a.elements[10],a.elements[11]),t.geometry.attributes.savedModelMatrix3.setXYZW(e,a.elements[12],a.elements[13],a.elements[14],a.elements[15])}function m(e,t){e.setAttribute("savedModelMatrix0",new n(new Float32Array(4*t),4)),e.setAttribute("savedModelMatrix1",new n(new Float32Array(4*t),4)),e.setAttribute("savedModelMatrix2",new n(new Float32Array(4*t),4)),e.setAttribute("savedModelMatrix3",new n(new Float32Array(4*t),4))}export default class extends e{constructor({camera:e,texture:n,color:s=16777215,textureScale:d=1,instanced:m=!1,cover:v=!1,opacity:c=1,...u}={}){if(!n||!n.isTexture)throw new Error("Invalid texture passed to the ProjectedMaterial");if(!e||!e.isCamera)throw new Error("Invalid camera passed to the ProjectedMaterial");e.updateProjectionMatrix(),e.updateMatrixWorld(),e.updateWorldMatrix();const M=e.matrixWorldInverse.clone(),x=e.projectionMatrix.clone(),h=e.matrixWorld.clone(),f=e.position.clone(),[p,y]=l(n,e,d,v);super({...u,lights:!0,uniforms:{...t.lambert.uniforms,baseColor:{value:new a(s)},texture:{value:n},viewMatrixCamera:{type:"m4",value:M},projectionMatrixCamera:{type:"m4",value:x},modelMatrixCamera:{type:"mat4",value:h},savedModelMatrix:{type:"mat4",value:new r},projPosition:{type:"v3",value:f},widthScaled:{value:p},heightScaled:{value:y},opacity:{value:c}},vertexShader:i(o.meshlambert_vert,{header:[m?"\n            attribute vec4 savedModelMatrix0;\n            attribute vec4 savedModelMatrix1;\n            attribute vec4 savedModelMatrix2;\n            attribute vec4 savedModelMatrix3;\n            ":"\n            uniform mat4 savedModelMatrix;\n          ","\n          uniform mat4 viewMatrixCamera;\n          uniform mat4 projectionMatrixCamera;\n          uniform mat4 modelMatrixCamera;\n\n          varying vec4 vWorldPosition;\n          varying vec3 vNormal;\n          varying vec4 vTexCoords;\n          "].join(""),main:[m?"\n            mat4 savedModelMatrix = mat4(\n              savedModelMatrix0,\n              savedModelMatrix1,\n              savedModelMatrix2,\n              savedModelMatrix3\n            );\n            ":"","\n          vNormal = mat3(savedModelMatrix) * normal;\n          vWorldPosition = savedModelMatrix * vec4(position, 1.0);\n          vTexCoords = projectionMatrixCamera * viewMatrixCamera * vWorldPosition;\n          "].join("")}),fragmentShader:i(o.meshlambert_frag,{header:"\n          uniform vec3 baseColor;\n          uniform sampler2D texture;\n          uniform vec3 projPosition;\n          uniform float widthScaled;\n          uniform float heightScaled;\n\n          varying vec3 vNormal;\n          varying vec4 vWorldPosition;\n          varying vec4 vTexCoords;\n\n          float map(float value, float min1, float max1, float min2, float max2) {\n            return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n          }\n        ","vec4 diffuseColor = vec4( diffuse, opacity );":"\n          vec2 uv = (vTexCoords.xy / vTexCoords.w) * 0.5 + 0.5;\n\n          // apply the corrected width and height\n          uv.x = map(uv.x, 0.0, 1.0, 0.5 - widthScaled / 2.0, 0.5 + widthScaled / 2.0);\n          uv.y = map(uv.y, 0.0, 1.0, 0.5 - heightScaled / 2.0, 0.5 + heightScaled / 2.0);\n\n          vec4 color = texture2D(texture, uv);\n\n          // this makes sure we don't sample out of the texture\n          // TODO handle alpha\n          bool inTexture = (max(uv.x, uv.y) <= 1.0 && min(uv.x, uv.y) >= 0.0);\n          if (!inTexture) {\n            color = vec4(baseColor, 1.0);\n          }\n\n          // this makes sure we don't render also the back of the object\n          vec3 projectorDirection = normalize(projPosition - vWorldPosition.xyz);\n          float dotProduct = dot(vNormal, projectorDirection);\n          if (dotProduct < 0.0) {\n            color = vec4(baseColor, 1.0);\n          }\n\n          // opacity from three.js\n          color.a *= opacity;\n\n          vec4 diffuseColor = color;\n        "})}),window.addEventListener("resize",()=>{this.uniforms.projectionMatrixCamera.value.copy(e.projectionMatrix);const[t,a]=l(n,e,d,v);this.uniforms.widthScaled.value=t,this.uniforms.heightScaled.value=a}),this.isProjectedMaterial=!0,this.instanced=m}}export{m as allocateProjectionData,s as project,d as projectInstanceAt};
//# sourceMappingURL=three-projected-material.js.map
