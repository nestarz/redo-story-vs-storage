{"version":3,"file":"three-projected-material.js","sources":["../node_modules/three-projected-material/build/ProjectedMaterial.module.js"],"sourcesContent":["import { ShaderMaterial, ShaderLib, Color, Matrix4, ShaderChunk, InstancedBufferAttribute } from 'three';\n\nfunction monkeyPatch(shader, { header = '', main = '', ...replaces }) {\n  let patchedShader = shader;\n\n  Object.keys(replaces).forEach(key => {\n    patchedShader = patchedShader.replace(key, replaces[key]);\n  });\n\n  return patchedShader.replace(\n    'void main() {',\n    `\n    ${header}\n    void main() {\n      ${main}\n    `\n  )\n}\n\nclass ProjectedMaterial extends ShaderMaterial {\n  constructor({\n    camera,\n    texture,\n    color = 0xffffff,\n    textureScale = 1,\n    instanced = false,\n    cover = false,\n    opacity = 1,\n    ...options\n  } = {}) {\n    if (!texture || !texture.isTexture) {\n      throw new Error('Invalid texture passed to the ProjectedMaterial')\n    }\n\n    if (!camera || !camera.isCamera) {\n      throw new Error('Invalid camera passed to the ProjectedMaterial')\n    }\n\n    // make sure the camera matrices are updated\n    camera.updateProjectionMatrix();\n    camera.updateMatrixWorld();\n    camera.updateWorldMatrix();\n\n    // get the matrices from the camera so they're fixed in camera's original position\n    const viewMatrixCamera = camera.matrixWorldInverse.clone();\n    const projectionMatrixCamera = camera.projectionMatrix.clone();\n    const modelMatrixCamera = camera.matrixWorld.clone();\n\n    const projPosition = camera.position.clone();\n\n    // scale to keep the image proportions and apply textureScale\n    const [widthScaled, heightScaled] = computeScaledDimensions(\n      texture,\n      camera,\n      textureScale,\n      cover\n    );\n\n    super({\n      ...options,\n      lights: true,\n      uniforms: {\n        ...ShaderLib['lambert'].uniforms,\n        baseColor: { value: new Color(color) },\n        texture: { value: texture },\n        viewMatrixCamera: { type: 'm4', value: viewMatrixCamera },\n        projectionMatrixCamera: { type: 'm4', value: projectionMatrixCamera },\n        modelMatrixCamera: { type: 'mat4', value: modelMatrixCamera },\n        // we will set this later when we will have positioned the object\n        savedModelMatrix: { type: 'mat4', value: new Matrix4() },\n        projPosition: { type: 'v3', value: projPosition },\n        widthScaled: { value: widthScaled },\n        heightScaled: { value: heightScaled },\n        opacity: { value: opacity },\n      },\n\n      vertexShader: monkeyPatch(ShaderChunk['meshlambert_vert'], {\n        header: [\n          instanced\n            ? `\n            attribute vec4 savedModelMatrix0;\n            attribute vec4 savedModelMatrix1;\n            attribute vec4 savedModelMatrix2;\n            attribute vec4 savedModelMatrix3;\n            `\n            : `\n            uniform mat4 savedModelMatrix;\n          `,\n          `\n          uniform mat4 viewMatrixCamera;\n          uniform mat4 projectionMatrixCamera;\n          uniform mat4 modelMatrixCamera;\n\n          varying vec4 vWorldPosition;\n          varying vec3 vNormal;\n          varying vec4 vTexCoords;\n          `,\n        ].join(''),\n        main: [\n          instanced\n            ? `\n            mat4 savedModelMatrix = mat4(\n              savedModelMatrix0,\n              savedModelMatrix1,\n              savedModelMatrix2,\n              savedModelMatrix3\n            );\n            `\n            : '',\n          `\n          vNormal = mat3(savedModelMatrix) * normal;\n          vWorldPosition = savedModelMatrix * vec4(position, 1.0);\n          vTexCoords = projectionMatrixCamera * viewMatrixCamera * vWorldPosition;\n          `,\n        ].join(''),\n      }),\n\n      fragmentShader: monkeyPatch(ShaderChunk['meshlambert_frag'], {\n        header: `\n          uniform vec3 baseColor;\n          uniform sampler2D texture;\n          uniform vec3 projPosition;\n          uniform float widthScaled;\n          uniform float heightScaled;\n\n          varying vec3 vNormal;\n          varying vec4 vWorldPosition;\n          varying vec4 vTexCoords;\n\n          float map(float value, float min1, float max1, float min2, float max2) {\n            return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n          }\n        `,\n        'vec4 diffuseColor = vec4( diffuse, opacity );': `\n          vec2 uv = (vTexCoords.xy / vTexCoords.w) * 0.5 + 0.5;\n\n          // apply the corrected width and height\n          uv.x = map(uv.x, 0.0, 1.0, 0.5 - widthScaled / 2.0, 0.5 + widthScaled / 2.0);\n          uv.y = map(uv.y, 0.0, 1.0, 0.5 - heightScaled / 2.0, 0.5 + heightScaled / 2.0);\n\n          vec4 color = texture2D(texture, uv);\n\n          // this makes sure we don't sample out of the texture\n          // TODO handle alpha\n          bool inTexture = (max(uv.x, uv.y) <= 1.0 && min(uv.x, uv.y) >= 0.0);\n          if (!inTexture) {\n            color = vec4(baseColor, 1.0);\n          }\n\n          // this makes sure we don't render also the back of the object\n          vec3 projectorDirection = normalize(projPosition - vWorldPosition.xyz);\n          float dotProduct = dot(vNormal, projectorDirection);\n          if (dotProduct < 0.0) {\n            color = vec4(baseColor, 1.0);\n          }\n\n          // opacity from three.js\n          color.a *= opacity;\n\n          vec4 diffuseColor = color;\n        `,\n      }),\n    });\n\n    // listen on resize if the camera used for the projection\n    // is the same used to render.\n    // do this on window resize because there is no way to\n    // listen for the resize of the renderer\n    // (or maybe do a requestanimationframe if the camera.aspect changes)\n    window.addEventListener('resize', () => {\n      this.uniforms.projectionMatrixCamera.value.copy(camera.projectionMatrix);\n\n      const [widthScaledNew, heightScaledNew] = computeScaledDimensions(\n        texture,\n        camera,\n        textureScale,\n        cover\n      );\n      this.uniforms.widthScaled.value = widthScaledNew;\n      this.uniforms.heightScaled.value = heightScaledNew;\n    });\n\n    this.isProjectedMaterial = true;\n    this.instanced = instanced;\n  }\n}\n\n// scale to keep the image proportions and apply textureScale\nfunction computeScaledDimensions(texture, camera, textureScale, cover) {\n  const ratio = texture.image.naturalWidth / texture.image.naturalHeight;\n  const ratioCamera = camera.aspect;\n  const widthCamera = 1;\n  const heightCamera = widthCamera * (1 / ratioCamera);\n  let widthScaled;\n  let heightScaled;\n  if (cover ? ratio > ratioCamera : ratio < ratioCamera) {\n    const width = heightCamera * ratio;\n    widthScaled = 1 / ((width / widthCamera) * textureScale);\n    heightScaled = 1 / textureScale;\n  } else {\n    const height = widthCamera * (1 / ratio);\n    heightScaled = 1 / ((height / heightCamera) * textureScale);\n    widthScaled = 1 / textureScale;\n  }\n\n  return [widthScaled, heightScaled]\n}\n\nfunction project(mesh) {\n  if (!mesh.material.isProjectedMaterial) {\n    throw new Error(`The mesh material must be a ProjectedMaterial`)\n  }\n\n  // make sure the matrix is updated\n  mesh.updateMatrixWorld();\n\n  // we save the object model matrix so it's projected relative\n  // to that position, like a snapshot\n  mesh.material.uniforms.savedModelMatrix.value.copy(mesh.matrixWorld);\n}\n\nfunction projectInstanceAt(index, instancedMesh, matrixWorld) {\n  if (!instancedMesh.isInstancedMesh) {\n    throw new Error(`The provided mesh is not an InstancedMesh`)\n  }\n\n  if (!instancedMesh.material.isProjectedMaterial) {\n    throw new Error(`The InstancedMesh material must be a ProjectedMaterial`)\n  }\n\n  if (\n    !instancedMesh.geometry.attributes.savedModelMatrix0 ||\n    !instancedMesh.geometry.attributes.savedModelMatrix1 ||\n    !instancedMesh.geometry.attributes.savedModelMatrix2 ||\n    !instancedMesh.geometry.attributes.savedModelMatrix3\n  ) {\n    throw new Error(\n      `No allocated data found on the geometry, please call 'allocateProjectionData(geometry)'`\n    )\n  }\n\n  if (!instancedMesh.material.instanced) {\n    throw new Error(`Please pass 'instanced: true' to the ProjectedMaterial`)\n  }\n\n  instancedMesh.geometry.attributes.savedModelMatrix0.setXYZW(\n    index,\n    matrixWorld.elements[0],\n    matrixWorld.elements[1],\n    matrixWorld.elements[2],\n    matrixWorld.elements[3]\n  );\n  instancedMesh.geometry.attributes.savedModelMatrix1.setXYZW(\n    index,\n    matrixWorld.elements[4],\n    matrixWorld.elements[5],\n    matrixWorld.elements[6],\n    matrixWorld.elements[7]\n  );\n  instancedMesh.geometry.attributes.savedModelMatrix2.setXYZW(\n    index,\n    matrixWorld.elements[8],\n    matrixWorld.elements[9],\n    matrixWorld.elements[10],\n    matrixWorld.elements[11]\n  );\n  instancedMesh.geometry.attributes.savedModelMatrix3.setXYZW(\n    index,\n    matrixWorld.elements[12],\n    matrixWorld.elements[13],\n    matrixWorld.elements[14],\n    matrixWorld.elements[15]\n  );\n}\n\nfunction allocateProjectionData(geometry, instancesCount) {\n  geometry.setAttribute(\n    'savedModelMatrix0',\n    new InstancedBufferAttribute(new Float32Array(instancesCount * 4), 4)\n  );\n  geometry.setAttribute(\n    'savedModelMatrix1',\n    new InstancedBufferAttribute(new Float32Array(instancesCount * 4), 4)\n  );\n  geometry.setAttribute(\n    'savedModelMatrix2',\n    new InstancedBufferAttribute(new Float32Array(instancesCount * 4), 4)\n  );\n  geometry.setAttribute(\n    'savedModelMatrix3',\n    new InstancedBufferAttribute(new Float32Array(instancesCount * 4), 4)\n  );\n}\n\nexport default ProjectedMaterial;\nexport { allocateProjectionData, project, projectInstanceAt };\n"],"names":["monkeyPatch","shader","header","main","replaces","patchedShader","Object","keys","forEach","key","replace","computeScaledDimensions","texture","camera","textureScale","cover","ratio","image","naturalWidth","naturalHeight","ratioCamera","aspect","heightCamera","widthScaled","heightScaled","project","mesh","material","isProjectedMaterial","Error","updateMatrixWorld","uniforms","savedModelMatrix","value","copy","matrixWorld","projectInstanceAt","index","instancedMesh","isInstancedMesh","geometry","attributes","savedModelMatrix0","savedModelMatrix1","savedModelMatrix2","savedModelMatrix3","instanced","setXYZW","elements","allocateProjectionData","instancesCount","setAttribute","InstancedBufferAttribute","Float32Array","ShaderMaterial","[object Object]","color","opacity","options","isTexture","isCamera","updateProjectionMatrix","updateWorldMatrix","viewMatrixCamera","matrixWorldInverse","clone","projectionMatrixCamera","projectionMatrix","modelMatrixCamera","projPosition","position","super","lights","ShaderLib","baseColor","Color","type","Matrix4","vertexShader","ShaderChunk","join","fragmentShader","vec4 diffuseColor = vec4( diffuse, opacity );","window","addEventListener","this","widthScaledNew","heightScaledNew"],"mappings":"kIAEA,SAASA,EAAYC,GAAQC,OAAEA,EAAS,GAAEC,KAAEA,EAAO,MAAOC,IACxD,IAAIC,EAAgBJ,EAMpB,OAJAK,OAAOC,KAAKH,GAAUI,QAAQC,IAC5BJ,EAAgBA,EAAcK,QAAQD,EAAKL,EAASK,MAG/CJ,EAAcK,QACnB,gBACA,SACER,+BAEEC,WA8KR,SAASQ,EAAwBC,EAASC,EAAQC,EAAcC,GAC9D,MAAMC,EAAQJ,EAAQK,MAAMC,aAAeN,EAAQK,MAAME,cACnDC,EAAcP,EAAOQ,OAErBC,EAA8B,EAAIF,EADpB,EAEpB,IAAIG,EACAC,EACJ,GAAIT,EAAQC,EAAQI,EAAcJ,EAAQI,EAAa,CAErDG,EAAc,GADAD,EAAeN,EALX,EAMyBF,GAC3CU,EAAe,EAAIV,MACd,CAELU,EAAe,GADe,EAAIR,EAThB,EAUYM,EAAgBR,GAC9CS,EAAc,EAAIT,EAGpB,MAAO,CAACS,EAAaC,GAGvB,SAASC,EAAQC,GACf,IAAKA,EAAKC,SAASC,oBACjB,MAAM,IAAIC,MAAM,iDAIlBH,EAAKI,oBAILJ,EAAKC,SAASI,SAASC,iBAAiBC,MAAMC,KAAKR,EAAKS,aAG1D,SAASC,EAAkBC,EAAOC,EAAeH,GAC/C,IAAKG,EAAcC,gBACjB,MAAM,IAAIV,MAAM,6CAGlB,IAAKS,EAAcX,SAASC,oBAC1B,MAAM,IAAIC,MAAM,0DAGlB,KACGS,EAAcE,SAASC,WAAWC,mBAClCJ,EAAcE,SAASC,WAAWE,mBAClCL,EAAcE,SAASC,WAAWG,mBAClCN,EAAcE,SAASC,WAAWI,mBAEnC,MAAM,IAAIhB,MACR,2FAIJ,IAAKS,EAAcX,SAASmB,UAC1B,MAAM,IAAIjB,MAAM,0DAGlBS,EAAcE,SAASC,WAAWC,kBAAkBK,QAClDV,EACAF,EAAYa,SAAS,GACrBb,EAAYa,SAAS,GACrBb,EAAYa,SAAS,GACrBb,EAAYa,SAAS,IAEvBV,EAAcE,SAASC,WAAWE,kBAAkBI,QAClDV,EACAF,EAAYa,SAAS,GACrBb,EAAYa,SAAS,GACrBb,EAAYa,SAAS,GACrBb,EAAYa,SAAS,IAEvBV,EAAcE,SAASC,WAAWG,kBAAkBG,QAClDV,EACAF,EAAYa,SAAS,GACrBb,EAAYa,SAAS,GACrBb,EAAYa,SAAS,IACrBb,EAAYa,SAAS,KAEvBV,EAAcE,SAASC,WAAWI,kBAAkBE,QAClDV,EACAF,EAAYa,SAAS,IACrBb,EAAYa,SAAS,IACrBb,EAAYa,SAAS,IACrBb,EAAYa,SAAS,KAIzB,SAASC,EAAuBT,EAAUU,GACxCV,EAASW,aACP,oBACA,IAAIC,EAAyB,IAAIC,aAA8B,EAAjBH,GAAqB,IAErEV,EAASW,aACP,oBACA,IAAIC,EAAyB,IAAIC,aAA8B,EAAjBH,GAAqB,IAErEV,EAASW,aACP,oBACA,IAAIC,EAAyB,IAAIC,aAA8B,EAAjBH,GAAqB,IAErEV,EAASW,aACP,oBACA,IAAIC,EAAyB,IAAIC,aAA8B,EAAjBH,GAAqB,mBA/QvE,cAAgCI,EAC9BC,aAAY1C,OACVA,EAAMD,QACNA,EAAO4C,MACPA,EAAQ,SAAQ1C,aAChBA,EAAe,EAACgC,UAChBA,GAAY,EAAK/B,MACjBA,GAAQ,EAAK0C,QACbA,EAAU,KACPC,GACD,IACF,IAAK9C,IAAYA,EAAQ+C,UACvB,MAAM,IAAI9B,MAAM,mDAGlB,IAAKhB,IAAWA,EAAO+C,SACrB,MAAM,IAAI/B,MAAM,kDAIlBhB,EAAOgD,yBACPhD,EAAOiB,oBACPjB,EAAOiD,oBAGP,MAAMC,EAAmBlD,EAAOmD,mBAAmBC,QAC7CC,EAAyBrD,EAAOsD,iBAAiBF,QACjDG,EAAoBvD,EAAOsB,YAAY8B,QAEvCI,EAAexD,EAAOyD,SAASL,SAG9B1C,EAAaC,GAAgBb,EAClCC,EACAC,EACAC,EACAC,GAGFwD,MAAM,IACDb,EACHc,QAAQ,EACRzC,SAAU,IACL0C,EAAmB,QAAE1C,SACxB2C,UAAW,CAAEzC,MAAO,IAAI0C,EAAMnB,IAC9B5C,QAAS,CAAEqB,MAAOrB,GAClBmD,iBAAkB,CAAEa,KAAM,KAAM3C,MAAO8B,GACvCG,uBAAwB,CAAEU,KAAM,KAAM3C,MAAOiC,GAC7CE,kBAAmB,CAAEQ,KAAM,OAAQ3C,MAAOmC,GAE1CpC,iBAAkB,CAAE4C,KAAM,OAAQ3C,MAAO,IAAI4C,GAC7CR,aAAc,CAAEO,KAAM,KAAM3C,MAAOoC,GACnC9C,YAAa,CAAEU,MAAOV,GACtBC,aAAc,CAAES,MAAOT,GACvBiC,QAAS,CAAExB,MAAOwB,IAGpBqB,aAAc9E,EAAY+E,EAA8B,iBAAG,CACzD7E,OAAQ,CACN4C,EACI,6MAMA,2DAGJ,oQASAkC,KAAK,IACP7E,KAAM,CACJ2C,EACI,mNAQA,GACJ,8NAKAkC,KAAK,MAGTC,eAAgBjF,EAAY+E,EAA8B,iBAAG,CAC3D7E,OAAQ,seAeRgF,gDAAiD,4hCAoCrDC,OAAOC,iBAAiB,SAAU,KAChCC,KAAKtD,SAASmC,uBAAuBjC,MAAMC,KAAKrB,EAAOsD,kBAEvD,MAAOmB,EAAgBC,GAAmB5E,EACxCC,EACAC,EACAC,EACAC,GAEFsE,KAAKtD,SAASR,YAAYU,MAAQqD,EAClCD,KAAKtD,SAASP,aAAaS,MAAQsD,IAGrCF,KAAKzD,qBAAsB,EAC3ByD,KAAKvC,UAAYA"}